Привет, "Вадим Макишвили — это я" (с)

Бивис — это полноценный фреймфорк, на котором можно сделать большой надёжный сайт.
Сейчас есть уже подобные решения, каждое со своими плюсами и минусами, у каждого свой порог сложности.
Наше решение очень простое. Сделать сайта на бивисе способен даже школьник, потому что школьнику нужно знать только html/css/js.
Об этом мы хотим рассказать сегодня.


Мы вам честно признаемся, у нас нет никаких целей на этой презентации.
Мы не ищем контрибьюторов. Потому что особо контрибьютить у нас нечего.
Мы не будем вас убеждать пересесть с ваших велосипедов на наш. Мы по-братски поделимся с вами своими придумками.

Когда-то я программировал на PHP. Я тогда использовал Смарти-шаблонизатор. Возможно, вы когда-то писали на Python, использовали Джанго.
Что такое обычное MVC-приложение?

1. Запрос из браузера попадает на какой-то http-сервер. Это может быть Apache, может быть Nginx. Это совершенно не важно

2. Дальше запрос направляется в контроллер - программу, написанную, например, на PHP или на Python.
Контроллер выполняет две простых задачи - получить данные из бекенда (или напрямую из базы данных) и передать данные в шаблоны представления

3. Шаблоны сегенерят html, и ответ уйдёт назад в браузер.

Эта схема знакома каждому из нас. Так? Ну, так бивис работает по этой же схеме.

1. Вместо Apache или Nginx у нас Node.js.
2. Вместо `php`-страничек мы пишем контроллер на серверном `js`. Он ходит куда-то за данными и отдаёт в шаблоны.
3. Шаблоны, тоже написанные на серверном `js`, генерят `html`, и ответ уходит в браузер.

Марат, расскажи, пожалуйста, как мы пишем контроллер.

####BEViS controller

```javascript
pages.declare('index', function () {

    return [
        {
            block: 'header'
        },
        {
            block: 'authorization',
            actionUrl: '/?task=login'
        }
    ];

});
```

Как вы видите, это обычный `javascript`. В бивис-приложении есть объект `pages`, у которого есть метод `declare`.
В нём мы декларируем, что `index`-страница будет состоять из двух компонентов - из шапки и формы авторизации.

Это обычный `JSON`. Я не знаю, любите ли вы писать сайты на чистом HTML, мы уже не любим.

И я расскажу вам почему.

Если посмотреть на любую картину вблизи - это же хаос - цветные мазочки-мазочки-мазочки. Ни черта не разобрать.

А если отойти от картины - всё видно. Это человек, это фонари, а это блики на асфальте

Кстати, это картина Леонида Афремова, написана мастихином. Чтобы вы знали, это не кисточка такая, а специальный интсрумент, похожий на строительный мастерок.
Но это к слову, к нашей теме не относится.

Когда мы получаем эскиз сайта от дизайнера, мы же смотрим на него и
видим не теги, которыми будем верстать страницу. Нет. Мы видим какие-то абстракции.

Ага - это будет шапка, это подвал, а тут форма авторизации. Кто-то называет это компонентами, модулями, контролами.

В Яндексе это называют блоками. Почему? Потому что в 2009 году Виталий Харисов рассказывал про вёрстку независимыми блоками.
С тех пор термин `блок` у нас и остался. Ну и пусть, хороший же термин.

Итак, Бивис-блок - это очень простой JSON. Простота - это очень важно. Чем предмет проще, тем легче им пользоваться.
Тем больше удовольствия от использования.

Бабушка моей жены любит печь хлеб. Мы подарили ей хлебопечку.

Но она не пользуется. Оказалось, пожилому человеку трудно запомнить
в какой последовательности какие кнопки нажимать - из инструкции старому человеку это
непонятно. Она по-прежнему пользуется газовой духовкой - а там что - открыл дверцу, сунул тесто, закрыл дверцу.

Какой веб-фреймворк для верстки ни возьми, он в какой-то степени напоминает хлебопечку. Мы с Маратом люди пожилые.
И в отделе у нас работают ребята, которым уже за тридцать, а кому-то и под сорок, как мне :)
Нам НА-ДО-Е-ЛО описывать страницу тегами, размечать их атрибутами. Это неоправданно сложно. Слишком много суеты, слишком мало смысла.

Поэтому вот так, мы решили, должно выглядеть описание страницы. Максимально просто, максимально плоско.

```javascript
[
    {
        block: 'header'
    },
    {
        block: 'authorization',
        actionUrl: '/?task=login'
    }
]
```

Здесь сказано, что на странице будет два блока - шапка и форма авторзации. Нет ни одного тега, ни одного атрибута.
Этого достаточно, чтобы Бивис сгенерил большой полноценный html, например такой:

```
<div class="header">
    <a class="header__logo" href="/"><img src="logo.png" /></a>

    <h1 class="header__title">Демо-страница</h1>

    <a class="header__rss" href="/?rss"><img src="rss.png" /></a>
</div>

<form class="authorization" action="/?task=login">
    <input class="authorization__login" value=""/>
    <button class="authorization__submit"/>
</form>
```

####Достаточно одного имени

И мы в Бивисе сделали одну крутую вещь, которой гордимся. Прям сильно-сильно гордимся.

Чтобы на странице появился блок, его достаточно позвать только по имени. Всё, больше о нём мне ничего знать не нужно. Вот, вообще не нужно.

И это так по человечески. Ведь, когда я хочу позвать к себе в гости Марата, я делаю этоочень просто - я зову его по имени и говорю: "Марат,
а приходи к нам в гости сегодня, жена блинов нажарит, посидим". А у Марата жена и двое детей,
к примеру. Я же не зову его отдельно, отдельно его жену и каждого ребенка в отдельности. Нет, только его,
а уж он сам приведёт всё семейство, будьте уверены.

```javascript
{
    друг: 'Марат'
}
```

И с блоком так же. Когда я хочу, чтобы на станице появился какой-то блок, Я НЕ ХОЧУ думать, о том, из каких тегов и атрибутов он внутри устроен.

####Необязательные параметры

Или когда я в ресторан прихожу и заказываю солянку, я же не даю указаний официанту: "Так, дорогуша, в солянке должно быть четыре кусочка картошки,
50 граммов салями, солёный огурчик обязательно нарежь меленько..." Нет. Я просто говорю: мне солянку. Ну максимум, меня могут спросить: "Вам со сметаной?"
Да, конечно, я люблю со сметаной:

```javascript
{
    суп: 'солянка',
    сметанаНужна: 'да'
}
```

Ну что, похоже на правду?

```javascript
{
    block: 'header'
    showSearch: true
}
```

Пусть блоки сами решают, в какой html они должны превратиться. Я не хочу думать, как они устроены внутри.
Создавать страницы из готовых блоков нам никогда не было ещё так просто.

####Блок - это...
Да и сами блоки создавать тоже просто, потому что это очень жизненная абстракция.

Как и во многих компонентных системах блок состоит из трёх составляющих
Во-первых это структура. Во-вторых, это представление. И в третьих, это поведение.

Структуру вы могли уже наблюдать. Это наш JSON. Который может быть древовидный.
Одни компоненты могут вкладываться в другие. Третьи компоненты могут иметь субкомпоненты
внутри себя и общаться с ними.

Представление - это наш любимый CSS, но вы его немного улучшили для своих целей.
Не без помощи готовых инструментов, об этом мы расскажем позже.

И поведение — это то, что связывает всё и делает интерактивной страницу и каждый блок по-отдельности
Здесь у нас тоже появилось несколько идей, которые мы реализовали. И о них мы тоже обязательно вам
расскажем.


Но начнём по порядку. Сначала Вадим расскажет вам про HTML-структуру.

##HTML

### Императивные шаблоны

Как мы генерим html в смарти, джанго и других MVC-фреймворках?

Мы пишем шаблоны, примерно такие.

```html
<p>Уважаемый {{ person }}</p>
<p>Ваш заказ от {{ date:"F j, Y" }} принят на обработку.</p>
<p>Пожалуйста, убедитесь, что всё выбрано верно:</p>

<ul>
{% for item in item_list %}
    <li>{{ item }}</li>
{% endfor %}
</ul>

{% if ordered_warranty %}
    <p>Гарантия - 12 месяцев.</p>
{% else %}
    <p>Со всеми неполадками обращайтесь в наш сервиcный центр.</p>
{% endif %}
```
Это фактически html-код, в который точечно вставлены программные переменные. Как будто шприцом с лекарством код обкололи.

Эти шаблоны мы пишем вот в этом месте.

В Смарти мы пишем их в файле tpl

В бивисе мы решаем эту задачу с помощью других шаблонов.

### Декларативные шаблоны

На `XSLT` писали? `XML` в `HTML` трансформировали? Тогда вы нас понимаете - шаблоны как в `XSLT`
А кто не писал на `XSL`, сейчас поймёте. Это легко.

Что это?

```css
h1 {
    color: red;
}
```

Даже школьник ответит: "Это CSS-селектор". Ну тогда поздравляем, вы умеете писать декларативные шаблоны.

`CSS`-селекторы - это пример самых настоящих декларативных шаблонов. Заголовок станет красным только тогда, когда он есть на странице. Если h1 на
странице нет, то и красить нечего, правда?

В этом вся соль декларативных языков программирования. Вместо инъекций шприцем (как в смарти-шаблонах) - только матчеры,
которые применяются к данным, если они есть. Это как горчичники - если есть куда их приложить - доктор их обязательно приложит.
Горчичники заматчатся или не заматчатся.

Предположим, наш контроллер выглядит так - на странице мы хотим видеть одну только шапку. Больше никаких блоков.

```javascript
pages.declare('index', function () {
    return {
        block: 'header'
    }
});
```

Мы хотим, чтобы из этого json-а на странице появился такой html:
```html
<div class="header"></div>
```

Идеальный декларативный шаблон на метаязыке мог бы выглядеть почти, как в CSS

```javascript
header {
    tag: div;
}
```

Этот шаблон бы читался так: если на странице объявлен блок header, вылей для него тег div.
В реальности, мы почти так и пишем, только на валидном javascript:

Это шаблон на Бивисе:

```javascript
bt.match('header', function (ctx) {
    ctx.setTag('div');
});
```

Похоже на это, правда?
```javascript
header {
    tag: div;
}
```

Мы матчимся по селектору, для которого выполняется функция.
А в функции сказано - создай тег `div`

Он довольно бесполезный. Чтобы вылить тег, столько всего написать надо.
Давайте усложнять. Я хочу, чтобы внутри шапки появился заголовок. Марат, расскажи, пожалуйста, как мы это делаем.

**Марат:**

Для начала мы добавляем элемент title, который будет загловком нашего блока.
Кроме того, мы передаём ему ещё какие-то данные, которые он должен отобразить.

```javascript
bt.match('header', function (ctx) {
    ctx.setTag('div');

    // Генерим внутри шапки новый btjson и устанавливаем его, как содержимое шапки
    ctx.setContent({
        elem: 'title', // указываем элемент title в качестве содержимого
        text: 'CodeFest 2014' // произвольный текст для заголовка
    });
});
```

И теперь мы матчимся на элемент title.

Задаём ему тег и содержимое, которые мы ранее передали через параметр.

```javascript
// регистрируем матчер для элемента title блока header
bt.match('header__title', function (ctx) {
    ctx.setTag('h1');

    // задаём содержимое заголовку из параметра text
    ctx.setContent(
        ctx.getParam('text')
    );
});
```
И в результате мы получаем такой html

```html
<div class="header">
    <h1 class="header__title">CodeFest 2014</h1>
</div>
```

Но это синтетический пример. Давайте посмотрим на реальный пример из Яндекса.

Это настоящее описание шапки, которое мы используем в Яндекс.Картах.

Единственное обязательное поле в этом JSON - это имя блока.
Все остальные поля - они необязательны, и блок `header` будет работать, даже если они все не указаны.

```javascript
{
    block: "y-header",

    view: "islet-search",
    showSearch: true,
    showSuggest: true,
}
```

При такой простой декларации шапки, конечная html-верстка может какой угодно сложной.

```html
<div>тут сложный некрасивый html</div>
```

Вот так это всё выглядит в браузере:

[живое демо]

#### Чем декларативные шаблоны лучше?

Кому-то из вас декларативные шаблоны не понравились, я вижу по вашим глазам. Для вас императивные шаблоны Смарти и Джанго привычнее, понятнее.
Мы должны вам объяснить, почему не используем их. Марат?

Императивные шаблоны остаются понятными, пока их немного.
Когда проект разрастается, все больше и больше визуальных фрагментов переиспользуются,
то и шаблоны становятся сложными и запутанными.

В такой ситуации BT-шаблоны позволяют сохранять сложность на одном уровне.
Более того, BT-шаблоны позволяют нам иметь явный и понятный API каждого фрагмента страницы.
BTJson блока - это его внешнее АПИ блока, а BT-шаблоны - это приватная реализация блоков.

Ощутите мощь этой идеи на этом примере. При такой простой декларации шапки, конечная html-верстка может какой угодно сложной.

Но самое ценное, что теперь можно как угодно менять шаблон, который генерирует html.
Но вызов блока, его АПИ остаются такими же. Нам не нужно переписывать страницу,
которая использует этот блок. Или другие блоки, которые его используют.

И мы можем не бояться, что что-то пойдёт не так. Потому что именно соблюдение АПИ как и гарантируют нам результат.

Возможно, кто из вас читал про Web Components.

Бивис реализует именно эту же идею. Но отличие в том, что Web Components пока ещё не поддерживаются браузерами, а бивис вы можете использовать уже сегодня.

Вадим, расскажи про представление в бивис-блоках.

## CSS блока

В стилях ради стабильности верстки  нам пришлось отказаться от двух привычных всех паттернов разработки.

### Смешивание блоков

Раньшем мы часто-часто использовали такой приём.

```
<div class="header authorization"></div>
```

Мы в бивисе больше так не делаем, потому что непонятно, что тут написано. Это шапка и форма авторизации одновременно? Можно, конечно, в одну тарелку налить борща и вишневого компота. И как это потом есть?

Это всё равно, что пытаться одновремено работать врачом и программистом, например. Мало толку, я знаю по себе. Сплошные накладки. Меня в то время спрашивали - ты кем работаешь и всегда вспоминал эпиход в любимом фильме:

&laquo;Мимино&raquo;, фильм георгия Данелия. Главный герой - лётчик.

[Видео]

Я точно так  отвечал на вопрос. Но героя фильма так нужда заставляла отвечать - если тбы он не назвался бы эндокринологом, его бы не поселили в гостиницу. А мне приходиось совмещать, потмоу что денег не хватало.
А верстальщиков кто заставляет смешивать блоки на одной ноде?

Ведь каждый раз, когда мы так делаем, мы закладываем бомбу в свой проект. Потому что в CSS есть грандиозная проблема для больших веб-сайтов:

В `CSS` нет надёжного механизма разруливания весов стилевых селекторов с одинаковой специфичностью. Какой селектор позже записан, тот и применится.

В `BEViS` мы отказались от смешивания блоков друг с другом. Нет миксов блоков на одной ноде - нет конфликтов.

### Модификации блоков

Ещё мы часто писали так. Это например, Бем-запись селекторов, но и до бема многие из нас писали похожим образом.

```html
<div class="button button_theme_normal button_shadow_yes">кнопка</div>
```

Есть некий базовый класс и несколько модификаторов, каждый добавляет к базовому классу что-то или переопределяет
какие-то стили из базового класса.

Чем это опасно?
Вы добавляете или изменяете какое-то свойство в одном из этих трёх классов, у вас нет никакой гарантии, что
ваши исправления не придут в конфликт весов со стилями других классов на этой ноде.

В большом проекте даже после небольших изменений в таких стилях хорошо бы перетестировать весь проект с нуля,
чтобы убедиться, что верстка не сломалась в тех блоках, где есть множественные классы. Проблема же в том, нет
другого механизма, кроме ручного пребора каждой страницы.

И это совсем не похоже на независимые блоки. Какая же это независимость, если даже внутри одного блока могут
родиться проблемы отображения? Трудно себе даже представить потенциальные конфликты в стилях, если мы смешаем
два разных блока на одной ноде.

Поэтому в Бивисе мы не используем модификации. Один блок - одно имя

### Имя и фамилия

При этом имя может быть простым — просто button, просто Олег, или просто Вадим. Но бывают случаи, когда оно должно быть более точным.
Например, Олег Бунин, Вадим Макеев. Чтобы добавить в имя уникальности.

Вот есть Вадим Макеев, а есть Вадим Макишвили. Представьте, вбегает сейчас в зал (вон в ту дверь) организатор конференции и кричит: "Эй, Вадим, в продакшене 404 ошибка на главной странице!".
Сколько Вадимов встрепенётся и занервничает? Да, все Вадимы. Но если он крикнет "Вадим Макишвили", то встрепенусь только я. А Вадим Макеев выдохнет.

Жизнь доказывает, что имени и фамилии достаточно для идентификации человека.

Когда мы зовём block: 'button', мы зовём наш блок по имени.
```html
<div class="button">
 ....
</div>
```
А если нам нужна какая-то очень конкретная кнопка, мы добаdляем в имя ещё и фамилию

```html
<div class="button_normal-shadow">
 ....
</div>
```

Понимаете, блок один - кнопка, но на одной странице она может быть с одним отображением, а другой с другим.
Разный вид одного и того же блока мы называем разным представлением. Разным `View`.


### View

А в декларации блока view указывается необязательным параметром:

```javascript
{
    block: 'button',
    view: 'normal-shadow'
}
```

При этом, если мне нужно эту кнопку отобразить в нажатом состоянии, мне не нужно писать отдельный вью, всё решается с помощью состояний кнопки.

Мы делаем это с помощью препроцессора.

### CSS-препроцессор

**Вадим:**
Кто сейчас не знает, что такое препроцессор? Все знают.

Кроме меня. Я относился к CSS-препроцессорам брезгливо. "Баловсто это", — я так считал, — "Тот же CSS, только с синтаксическим сахаром."
А сахар я не люблю, кофе могу пить и несладкий.

Только оказалось, что сахар в препроцессорах - это не то, ради чего они нужны.
Мы с их помощью делаем верстку гибкой и модульной.

Как мы решаем задачу?

### Публичные селекторы и приватные функции

```css
.button {
    skin-common()
    skin-theme-normal()
}

.button_normal-shadow {
    skin-common();
    skin-theme-normal();
    skin-shadow();
}

skin-common() {
    /* общие стили для кнопки */
}

skin-theme-normal() {
    /* цветовая тема */
}

skin-shadow() {
    /* стили добавляют тень */
}

```
Мы создаём два селектора, независимых друг от друга. Каждый - самодостаточный.
В каждом из них я зову некотрые функции, как мы это делаем в `JS`.

Это своего рода геттеры - функции, которые что-то возвращают вместо себя.
В Stylus-препроцессоре они называются миксины. Примеси.

`skin-common()`, `skin-theme-normal()`, `skin-shadow()` - это так называемые миксины

Мощь в том, что эти функции приватны. Они не попадают напрямую в скомпилироанный css-файл. Пока из конкретного селектора не вызову этот миксин, его содержимое нигде не светится

### Все конфликты под контролем

И здесь же, на этапе препроцессора могу разрулить все конфликты, если они возникнут

```css
.button_normal-shadow {
    skin-common();
    skin-theme-normal();
    skin-shadow();

    /* а здесь разрулил все конфликты этих миксинов */
}
```

То есть мы решаем все конфликты на этапе разработки, а не на этапе использования.
В браузер пойдёт для этого блока один css-селектор. Гарантированно работающий.

Идею так использовать препроцессор мы позаимствовали у Романа Комарова. Он предложил такую же схему для своего CSS-фреймворка Stylobat. Рома - это тот парень,
который является сейчас мейнтейнером препроцессора Stylus. Гениальный верстальщик, добрый человек. Рома, спасибо тебе большое!

Марат, расскажи, пожалуйста, как мы пишем js для блоков на странице?

## JS

### В маленьких проектах

В маленьких проектах мы делаем так:

```javascript
$(document).ready(function() {

    var form = $('#my-form');
    form.submit(onSubmited);

    function onSubmited() {
        if ($('#my-form .button').hasClass('disabled')) {
            return false;
        }
    }

});
```

Для каждого блока мы описываем, что он должен делать.
Здесь же описываем реакции на пользовательские события.

В бивисе мы делаем то же самое, только не внутри ```$( document ).ready()```, а внутри модуля.

### В маленьких проектах с модулями

У нас есть своя модульная система, она асинхронная на всех этапах своей работы.
Примерно так выглядит описание модуля в терминах модульной системы.

То есть, тот же код, что на предыдущем слайде, только лишённый глобального экспорта.

```javascript
modules.define(
    'form',
    ['jquery'],
    function(provide, $) {

        var form = $('#my-form');
        form.submit(onSubmited);

        function onSubmited() {
            if ($('#my-form .button').hasClass('disabled')) {
                return false;
            }
        }

        provide(form);
    }
);
```
Сам код остался тем же, обвязка немного поменялась.

Мы объявили модуль в первой строке.
Во второй мы далеи модулю имя.
В третьей  описали зависимости — в нашем случае это только JQuery

И мы описали то, из чего состоит модуль. То есть то, что этот модуль экспортирует.

### В Бивисе = модули + YBlock

На самом деле, внутри модулей мы не используем напрямую JQuery. Мы используем свой базовый класс для написания блоков.

Этот класс даёт нам возможность описывать блок в виде абстракции над DOM-деревом.
И более того, мы не используем JQuery и в процессе написания самого блока, а не только использования.

```javascript
modules.define(
    'form',
    ['button', 'input', 'y-block'],
    function(provide, button, input, YBlock) {

        var Form = inherit(YBlock, {
            __constructor: function () {
                this._submitButton = YButton.find(this);
                this._bindTo(this.getDomNode(), 'submit', this._onSubmited);

            },

            _onSubmited: function (e) {
                if (this._submitButton.isDisabled()) {
                    e.preventDefault();
                } else {
                    this.emit('submit');
                }
            }
        });

        provide(Form);
    }
);
```

### Почему не jQuery?

Расскажи, пожалуйста, почему не jQuery? Его же все знают.

Во-первых, мы получаем код, который можно вновь и вновь использовать.

А во-вторых — абстракцию над HTML-структурой блока. Нам не важно, как блок представлен на странице.
Порой нам даже не важно, где он лежит - в body или в каком-то другом элементе.

Мы переходим от DOM-взгляда на компонент на другой. Мы смотрим на блоки с точки зрения семантики их работы.

### Поведение отделено от отображения

Ещё у Бивиса получилось разделить визуальное отображение и поведение блока.

Когда бивис сгенерит html для шапки, вы увидите там такое:

```html
<div
    class="header"
    data-block="header">
</div>
```

Слово `header`, записанное в атрибуте class участвует исключительно в стилях.
А то, что написано в `data-block` - именно по этому атрибуту Бивис находит шапку и назначает ей js-поведение.

В бивисе блок может иметь один css-класс, а дата-атрибут совершенно другой. То есть вы можете спокойно удалить атрибут -
поведение вы потеряете, но внешний вид блока не сломается.

### Они пересекаются в состояниях блока

Едиственное место, где поведение и отображение пересекаются, это состояния блока. Кнопка может быть нажата или отжата. Это состояние кнопки. Когда она нажата, она должна выглядеть вдавленной, например. А кога она задизейблена - серой.

Этого никак не избежать, потому что и в жизни оно так устроено. В разных состояниях я выгляжу совершенно по-разному. Мой внешний вид менятеся.

Когда я нахожусь в состоянии эйфории - мои глаза светятся, лицо улыбается.
Когда я в состоянии усталости, мои плечи опущены и выгляжу я несчастнее некуда.

То есть внешний вид неразрывно связан с моим поведением. Это же мы продемонстриуем на простом примере.

Та же форма авторизации: по нажатию на кнопку сабмита надо проверить поле логина. Если пустое - обвести поле логина стыдливой красной рамкой. То есть изменить отображение блока,
сменить его состояние с обычного на тревожное.

Из `js` мы добавляем дополнительный класс, который отвечает за изменение внешнего вида в состоянии "тревога".

Вот что произойдёт в html-элемнте блока

```html
<input class="login _unfilled" type="text"/>
```

а вот что мы заранее напишем в стилях

```css
/* обычное состояние */
.login {
    ...
}

/* тревожное состояние */
.login._unfilled {
    border: 1px solid red;
}
```

И когда мы на клиенте проверим, что поле логина пустое, мы добавим в ноду к инпуту класс "_unfilled"
Мы называем такие классы состояниями: State.

Почему класс начинается с подчёркивания? Чтобы подчернуть, что он приватный для блока и чтобы легче его замечать.

Теперь понимаете, почему мы назвали наш подход BEViS?

```
B — [B]lock
E — [E]lement
Vi— [Vi]ew
S — [S]tate
```

Мы почти закончили. Марат, расскажи нам, как блок представлен на файловой системе.

## Файлы и блоки

### На файловой системе...

У каждого из нас есть дом. У меня есть. пуст не дом, а квартира в многоэтажке. Это такое место откуда мы утром выходим на работу, а вечером с работы возвращается.
У блоков тоже есть такое место, где они отдыхают и ждут, пока их позовут поработать на странице

В корне проекта есть директория `/blocks`, в ней живут все блоки.

````
blocks/
├── header/
│   ├── header.bt.js
│   ├── header.styl
│   └── header.js
└── form/
     ├── form.bt.js
     ├── form.styl
     └── form.js
````

Каждый блок живёт в своей собственной квартирке, где всё рядышком — шаблоны для генерации html в `bt.js`, стили в `styl`, клиентский яваскрипт в `js`.

### ENB
А когда бивис генерит страницу, специальный сбощик ходит по проекту, и собирает из бочных ресурсов страничный ресурсы.
Здесь в первом ряду сидит мой друг Марат - автор такого сборщика. Когда я закончу презентацию, он станет рядом со мной и будет отвечать на вопросы. Я очень хочу, чтобы вы задали ему правильный вопрос:

[ENB](https://github.com/enb-make/enb)

Марат, уже есть Ant, Maven, Make, Grunt, Gulp. Зачем ты сделал ещё один? Задайте ему такой вопрос, пусть ответит :)

### ENB-конфигуратор

А ещё у твоего сборщика очень понятная документация и робот-конфигуратор, с помощью которого создавать конфиг для сборщика сможет школьник.

### Bevis-ui документация

Мы написали документацию и про бивис. Она понятная, легкая для воприятия. Мы писали её для живых людей.

### Быстрый старт

Начать работать на бивисе просто. Три команды:

[Слайд](http://makishvili.github.io/bevis/index.html?full#56)

```
git clone git@github.com:bevis-ui/bevis-stub.git your-project
cd your-project
make
```

После этого мы открываем в браузере ```localhost:8000``` и говорим: "Привет, Бивис!"

### TodoMVC

Кроме того, мы реализовали страницу в стиле TodoMVC на Бивисе.

Можно сравнить Бивис с другими MVC и компонентными фреймворками.

Ещё мы сделали движдок для блогов. Он такой же как Октопресс, только не на руби и джекилле, а на серверном яваскрипте.

## Заключение

Нам нравится пользоваться Бивисом.

Во-первых, потому что мы сами его придумали. Своя рубашка ближе к телу, кто спорит :)

Во-вторых, бивис на 99% - это обычный javascript.

В-третьих, код бивиса на 100% юнит-тестами.

И последняя причина, код написан в очень понятном кодстайле, которого придерживается команда Яндекс.Карт.

Мы не просим становиться нашими контрибьюторами, потому что особо нечего контрибьютить. Ведь наши
инструменты просто работают, а бивис-подход вполне жизнеспособный, мы доказали это на нескольких проектах.
Например `beta.maps.yandex.ru` сделан на бивисе.

Мы не предлагаем вам пересаживаться на бивис, если у вас маленькие сайты. Мы осознаём, что верстать на бивисе маленький сайтик —
это все равно что экскаватором пытаться выкопать лунку для гольфа — вместо лунки всё равно получится яма для саженца.

Но если вдруг вам нужно перекопать большое поле и вы хотите быть уверены, что в процессе копания не повредите
какие-то важные подземные коммуникации, тогда бивис - и для вас тоже.

Да, Бивис - для больших сайтов, которым нужна простота и надёжность.

С вами была команда Яндекс.Карт и её представители на этой конференции - Вадим Макишвили и Марат Дулин. Спасибо вам большое за внимание!
