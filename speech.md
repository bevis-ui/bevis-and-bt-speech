Привет, "Вадим Макишвили — это я" (с)

Я прилетел к вам с юга Украины, из Симферополя. Сейчас там тепло и солнечно. А у вас холодно и снег. И я у вас замёрз.
Мне никто не сказал, что у вас ещё зима. :)

Но главное, что здесь, на конеференции, очень тепло, уютно и по-домашнему. Вы - прекрасны. Организаторы - чудесны. Спасибо вам большое, что позвали!

Эта конференция - это какой-то праздник. Я не видел ещё такого количества счастливых разработчиков вместе.
Столько чудесный команд, так много сильных специалистов. С некоторыми из вам мне повезло познакомиться.

Я прилетел к вам не только для того, чтобы рассказать про Бивис, который мы придумали в Яндекс.Картах.
Текст этого доклада уже есть на гитхабе в виде статьи, ей можно прочитать хоть сейчас.

В первую очередь я хочу познакомить вас вас с необыкновенным человеком.

С человеком, который доказывает, что можно быть гениальным программистом и не быть занудой.

Он умеет не только писать качественный код, но и параллельно писать документацию к коду.
Да такую документацию, которую хочется читать живым людям.

Его продукты набирают популярность уже не только внутри Яндекса, но и снаружи.
Такие известные всем проекты, как jquery, bootstrap и angular, уже используют один из продуктов этого человека.

Итак, я с огромным удовольствием представляю. Мой хороший друг и талантливейший программист — Марат Дулин!

**Марат:** Привет.

[**Марат:** Если кто не знает Вадима, я коротенько про него расскажу...]

Сегодня мы расскажем вам по Бивис — это полноценный фреймфорк, на котором можно сделать большой надёжный сайт.
Сейчас есть уже подобные решения, каждое со своими плюсами и минусами, у каждого свой порог сложности.
Наше решение очень простое. Сделать сайта на бивисе способен даже школьник, потому что школьнику нужно знать только html/css/js.
Об этом мы хотим рассказать сегодня.


**Вадим:** Мы вам честно признаемся, у нас нет никаких целей на этой презентации.
Мы не ищем контрибьюторов. Потому что особо контрибьютить у нас нечего.
Мы не говорим, что принесли вам новую веб-религию и вам срочно нужно бросать
свои велосипеды и пересаживаться на наш. Мы по-братски поделимся с вами своими придумками.

Кстати, если кто не знает, Бивис - это тот, что слева :)

Когда-то я программировал на PHP. Я тогда использовал Смарти-шаблонизатор. Возможно, вы когда-то писали на Python, использовали Джанго.
Что такое обычное MVC-приложение?

1. Запрос из браузера попадает на какой-то http-сервер. Это может быть Apache, может быть Nginx. Это совершенно не важно

2. Дальше запрос направляется в контроллер - программу, написанную, например, на PHP или на Python.
Контроллер выполняет две простых задачи - получить данные из бекенда (или напрямую из базы данных) и передать данные в шаблоны представления

3. Шаблоны сегенерят html, и ответ уйдёт назад в браузер.

Эта схема знакома каждому из нас. Так? Ну, так бивис работает по этой же схеме.

1. Вместо Apache или Nginx у нас Node.js.
2. Вместо `php`-страничек мы пишем контроллер на серверном `js`. Он ходит куда-то за данными и отдаёт в шаблоны.
3. Шаблоны, тоже написанные на серверном `js`, генерят `html`, и ответ уходит в браузер.

Марат, расскажи, пожалуйста, как мы пишем контроллер.

####BEViS controller

```javascript
pages.declare('index', function () {

    return [
        {
            block: 'header'
        },
        {
            block: 'authorization',
            actionUrl: '/?task=login'
        }
    ];

});
```

**Марат:** Как вы видите, это обычный `javascript`. В бивис-приложении есть объект `pages`, у которого есть метод `declare`.
В нём мы декларируем, что `index`-страница будет состоять из двух компонентов - из шапки и формы авторизации.

Это обычный `JSON`. Я не знаю, любите ли вы писать сайты на чистом HTML, мы уже не любим.

**Вадим:** И я расскажу вам почему.

Если посмотреть на любую картину вблизи - это же хаос - цветные мазочки-мазочки-мазочки. Ни черта не разобрать.

А если отойти от картины - всё видно. Это человек, это фонари, а это блики на асфальте

Кстати, это картина Леонида Афремова, написана мастихином. Чтобы вы знали, это не кисточка такая, а специальный интсрумент, похожий на строительный мастерок.
Но это к слову, к нашей теме не относится.

Когда мы получаем эскиз сайта от дизайнера, мы же смотрим на него и
видим не теги, которыми будем верстать страницу. Нет. Мы видим какие-то абстракции.

Ага - это будет шапка, это подвал, а тут форма авторизации. Кто-то называет это компонентами, модулями, контролами.

В Яндексе это называют блоками. Почему? Потому что в 2009 году Виталий Харисов рассказывал про вёрстку независимыми блоками.
С тех пор термин `блок` у нас и остался. Ну и пусть, хороший же термин.

Итак, Бивис-блок - это очень простой JSON. Простота - это очень важно. Чем предмет проще, тем легче им пользоваться.
Тем больше удовольствия от использования.

Бабушка моей жены любит печь хлеб. Мы подарили ей хлебопечку.

Но она не пользуется. Оказалось, пожилому человеку трудно запомнить
в какой последовательности какие кнопки нажимать - из инструкции старому человеку это
непонятно. Она по-прежнему пользуется газовой духовкой - а там что - открыл дверцу, сунул тесто, закрыл дверцу.

Какой веб-фреймворк для верстки ни возьми, он в какой-то степени напоминает хлебопечку. Мы с Маратом люди пожилые.
И в отделе у нас работают ребята, которым уже за тридцать, а кому-то и под сорок, как мне :)
Нам НА-ДО-Е-ЛО описывать страницу тегами, размечать их атрибутами. Это неоправданно сложно. Слишком много суеты, слишком мало смысла.

Поэтому вот так, мы решили, должно выглядеть описание страницы. Максимально просто, максимально плоско.

```javascript
[
    {
        block: 'header'
    },
    {
        block: 'authorization',
        actionUrl: '/?task=login'
    }
]
```

Здесь сказано, что на странице будет два блока - шапка и форма авторзации. Нет ни одного тега, ни одного атрибута.
Этого достаточно, чтобы Бивис сгенерил большой полноценный html, например такой:

```
<div class="header">
    <a class="header__logo" href="/"><img src="logo.png" /></a>

    <h1 class="header__title">Демо-страница</h1>

    <a class="header__rss" href="/?rss"><img src="rss.png" /></a>
</div>

<form class="authorization" action="/?task=login">
    <input class="authorization__login" value=""/>
    <button class="authorization__submit"/>
</form>
```

####Достаточно одного имени

И мы в Бивисе сделали одну крутую вещь, которой гордимся. Прям сильно-сильно гордимся.

Чтобы на странице появился блок, его достаточно позвать только по имени. Всё, больше о нём мне ничего знать не нужно. Вот, вообще не нужно.

И это так по человечески. Ведь, когда я хочу позвать к себе в гости Марата, я делаю этоочень просто - я зову его по имени и говорю: "Марат,
а приходи к нам в гости сегодня, жена блинов нажарит, посидим". А у Марата жена и двое детей,
к примеру. Я же не зову его отдельно, отдельно его жену и каждого ребенка в отдельности. Нет, только его,
а уж он сам приведёт всё семейство, будьте уверены.

```javascript
{
    друг: 'Марат'
}
```

И с блоком так же. Когда я хочу, чтобы на станице появился какой-то блок, Я НЕ ХОЧУ думать, о том, из каких тегов и атрибутов он внутри устроен.

####Необязательные параметры

Или когда я в ресторан прихожу и заказываю солянку, я же не даю указаний официанту: "Так, дорогуша, в солянке должно быть четыре кусочка картошки,
50 граммов салями, солёный огурчик обязательно нарежь меленько..." Нет. Я просто говорю: мне солянку. Ну максимум, меня могут спросить: "Вам со сметаной?"
Да, конечно, я люблю со сметаной:

```javascript
{
    суп: 'солянка',
    сметанаНужна: 'да'
}
```

Ну что, похоже на правду?

```javascript
{
    block: 'header'
    showSearch: true
}
```

**Марат:** Пусть блоки сами решают, в какой html они должны превратиться. Я не хочу думать, как они устроены внутри.
Создавать страницы из готовых блоков нам никогда не было ещё так просто.

####Блок - это...
Да и сами блоки создавать тоже просто, потому что это очень жизненная абстракция.

Как и во многих компонентных системах блок состоит из трёх составляющих
Во-первых это структура. Во-вторых, это представление. И в третьих, это поведение.

Структуру вы могли уже наблюдать. Это наш JSON. Который может быть древовидный.
Одни компоненты могут вкладываться в другие. Третьи компоненты могут иметь субкомпоненты
внутри себя и общаться с ними.

Представление - это наш любимый CSS, но вы его немного улучшили для своих целей.
Не без помощи готовых инструментов, об этом мы расскажем позже.

И поведение — это то, что связывает всё и делает интерактивной страницу и каждый блок по-отдельности
Здесь у нас тоже появилось несколько идей, которые мы реализовали. И о них мы тоже обязательно вам
расскажем.


Но начнём по порядку. Сначала Вадим расскажет вам про HTML-структуру.

##HTML

### Императивные шаблоны

**Вадим:** Как мы генерим html в смарти, джанго и других MVC-фреймворках?

Мы пишем шаблоны, примерно такие.

```html
<p>Уважаемый {{ person }}</p>
<p>Ваш заказ от {{ date:"F j, Y" }} принят на обработку.</p>
<p>Пожалуйста, убедитесь, что всё выбрано верно:</p>

<ul>
{% for item in item_list %}
    <li>{{ item }}</li>
{% endfor %}
</ul>

{% if ordered_warranty %}
    <p>Гарантия - 12 месяцев.</p>
{% else %}
    <p>Со всеми неполадками обращайтесь в наш сервиcный центр.</p>
{% endif %}
```
Это фактически html-код, в который точечно вставлены программные переменные. Как будто шприцом с лекарством код обкололи.

Эти шаблоны мы пишем вот в этом месте.

В Смарти мы пишем их в файле tpl

В бивисе мы решаем эту задачу с помощью других шаблонов.

### Декларативные шаблоны

На `XSLT` писали? `XML` в `HTML` трансформировали? Тогда вы нас понимаете - шаблоны как в `XSLT`
А кто не писал на `XSL`, сейчас поймёте. Это легко.

Что это?

```css
h1 {
    color: red;
}
```

Даже школьник ответит: "Это CSS-селектор". Ну тогда поздравляем, вы умеете писать декларативные шаблоны.

`CSS`-селекторы - это пример самых настоящих декларативных шаблонов. Заголовок станет красным только тогда, когда он есть на странице. Если h1 на
странице нет, то и красить нечего, правда?

В этом вся соль декларативных языков программирования. Вместо инъекций шприцем (как в смарти-шаблонах) - только матчеры,
которые применяются к данным, если они есть. Это как горчичники - если есть куда их приложить - доктор их обязательно приложит.
Горчичники заматчатся или не заматчатся.

Предположим, наш контроллер выглядит так - на странице мы хотим видеть одну только шапку. Больше никаких блоков.

```javascript
pages.declare('index', function () {
    return {
        block: 'header'
    }
});
```

Мы хотим, чтобы из этого json-а на странице появился такой html:
```html
<div class="header"></div>
```

Идеальный декларативный шаблон на метаязыке мог бы выглядеть почти, как в CSS

```javascript
header {
    tag: div;
}
```

Этот шаблон бы читался так: если на странице объявлен блок header, вылей для него тег div.
В реальности, мы почти так и пишем, только на валидном javascript:

Это шаблон на Бивисе:

```javascript
bt.match('header', function (ctx) {
    ctx.setTag('div');
});
```

Похоже на это, правда?
```javascript
header {
    tag: div;
}
```

Мы матчимся по селектору, для которого выполняется функция.
А в функции сказано - создай тег `div`

Он довольно бесполезный. Чтобы вылить тег, столько всего написать надо.
Давайте усложнять. Я хочу, чтобы внутри шапки появился заголовок. Марат, расскажи, пожалуйста, как мы это делаем.

**Марат:**

Для начала мы добавляем элемент title, который будет загловком нашего блока.
Кроме того, мы передаём ему ещё какие-то данные, которые он должен отобразить.

```javascript
bt.match('header', function (ctx) {
    ctx.setTag('div');

    // Генерим внутри шапки новый btjson и устанавливаем его, как содержимое шапки
    ctx.setContent({
        elem: 'title', // указываем элемент title в качестве содержимого
        text: 'CodeFest 2014' // произвольный текст для заголовка
    });
});
```

И теперь мы матчимся на элемент title.

Задаём ему тег и содержимое, которые мы ранее передали через параметр.

```javascript
// регистрируем матчер для элемента title блока header
bt.match('header__title', function (ctx) {
    ctx.setTag('h1');

    // задаём содержимое заголовку из параметра text
    ctx.setContent(
        ctx.getParam('text')
    );
});
```
И в результате мы получаем такой html

```html
<div class="header">
    <h1 class="header__title">CodeFest 2014</h1>
</div>
```

Но это синтетический пример. Давайте посмотрим на реальный пример из Яндекса.

Это настоящее описание шапки, которое мы используем в Яндекс.Картах.

Единственное обязательное поле в этом JSON - это имя блока.
Все остальные поля - они необязательны, и блок `header` будет работать, даже если они все не указаны.

```javascript
{
    block: "y-header",

    view: "islet-search",
    showSearch: true,
    showSuggest: true,
}
```

При такой простой декларации шапки, конечная html-верстка может какой угодно сложной.

```html
<div>тут сложный некрасивый html</div>
```

Вот так это всё выглядит в браузере:

[живое демо]

#### Чем декларативные шаблоны лучше?

**Вадим:** Кому-то из вас декларативные шаблоны не понравились, я вижу по вашим глазам. Для вас императивные шаблоны Смарти и Джанго привычнее, понятнее.
Мы должны вам объяснить, почему не используем их. Марат?

**Марат:** Императивные шаблоны остаются понятными, пока их немного.
Когда проект разрастается, все больше и больше визуальных фрагментов переиспользуются,
то и шаблоны становятся сложными и запутанными.

В такой ситуации BT-шаблоны позволяют сохранять сложность на одном уровне.
Более того, BT-шаблоны позволяют нам иметь явный и понятный API каждого фрагмента страницы.
BTJson блока - это его внешнее АПИ блока, а BT-шаблоны - это приватная реализация блоков.

Ощутите мощь этой идеи на этом примере. При такой простой декларации шапки, конечная html-верстка может какой угодно сложной.

Но самое ценное, что теперь можно как угодно менять шаблон, который генерирует html.
Но вызов блока, его АПИ остаются такими же. Нам не нужно переписывать страницу,
которая использует этот блок. Или другие блоки, которые его используют.

И мы можем не бояться, что что-то пойдёт не так. Потому что именно соблюдение АПИ как и гарантируют нам результат.

Возможно, кто из вас читал про Web Components.

Бивис реализует именно эту же идею. Но отличие в том, что Web Components пока ещё не поддерживаются браузерами, а бивис вы можете использовать уже сегодня.

Вадим, расскажи про представление в бивис-блоках.

## CSS блока

Начнём мы с заявления, с которым многие из вас будут категорически не согласны. Но тем интереснее, правда?

Поэтому я прошу вашего безраздельного внимания.

### Смешивание блоков

**Вадим:** Мы убеждены, что имя у блока должно быть одно. Мы не согласны с теми из вас, кто использует в верстке такой приём:

```
<div class="header authorization"></div>
```

Это что? Это шапка и форма авторизации одновременно? Это, простите, как возможно?

Вы смотрели "Мимино"? Ну, там ещё Вахтанг Кикабидзе играет лётчика? "Ларису Ивановну хачу". Ну, вспомнили?

Там есть такой эпизод. Ммино прилетает в Москву и селится в гостиницу. А там проводится всесоюзный слёт эндокринологов. Места есть только для эндокринологов.
А он пришёл туда в форме летчика. Представляете себе форму? Синий китель, стрелки на брюках, погоны, фуражка с эмблемой авиации...

И на вопрос: вы что - летчик? Он отвечает:

— Да... Иногда... Вообще-то, я эндокринолог.

Хороший летчик не может быть одновременно хорошим эндокринологом. Попробуй совмещать обе профессии - это же сплошные проблемы,
такова жизнь, не нам с ней спорить.

Я не просто так говорю, я же пробовал. Работал одновременно врачом и программистом.

И в верстке с множественными именами сплошные проблемы. Хаос и боль, потому что в CSS есть грандиозная проблема для больших веб-сайтов:

В `CSS` нет надёжного механизма разруливания весов стилевых селекторов с одинаковой специфичностью. Какой селектор позже записан, тот и применится.

Но я смешивал специальности из-за нужды, мне денег не хватало семью кормить. А верстальщиков-то никто не вынуждает смешивать абстракции.

В `BEViS` мы отказались от смешивания блоков друг с другом. Нет миксов блоков на одной ноде - нет конфликтов.

Бивис-блок имеет всегда только одно имя. Всегда одно. Это важно.

### Имя и фамилия

Имя у блока может быть простым — просто Марат, или просто Вадим, или просто header. Но бывают случаи, когда оно должно быть более точным.
Например, Марат Дулин, или Вадим Макишвили. Чтобы добавить в имя уникальности.

Кого из вас зовут Вадим?

Представьте, вбегает сейчас в зал (вон в ту дверь) организатор конференции и кричит: "Эй, Вадим, в продакшене 404 ошибка на главной странице!".
Сколько Вадимов встрепенётся и занервничает? Да, все Вадимы. Но если он крикнет "Вадим Макишвили", то встрепенусь только я.

Жизнь доказывает, что имени и фамилии достаточно для идентификации человека.

Когда мы зовём block: 'header', мы зовём наш блок по имени. Но если мы хотим добавить ещё больше уникальности, мы добавляем здесь
же "фамилию", которую у блока мы именуем словом `view`

```javascript
{
    block: 'header',
    view: 'search'
}
```

Читать это следует так: создай на странице шапку, да не простую, а поисковую.
Получится такой HTML:

```html
<div class="header_search">
    ....
</div>
```

Понимаете, блок один - шапка, но на одной странице она может быть поисковая, а на другой непоисковая.
Поэтому у неё есть два варианта отображения на странице, два представления, две темы, два скина, две шкурки...
два `View`. Разный вид одного и того же блока мы называем разным представлением. Разным `View`.

Но класс у блока, как вы видите, у нас по-прежнему один. Это тоже важно.

### Модификации блоков

**Марат:**
Не знаю, как у вас в проектах, у нас в Яндексе довольно часто можно встретить такие записи:

```html
<div class="button button_theme_normal button_shadow_yes">кнопка</div>
```

Есть некий базовый класс и несколько модификаторов, каждый добавляет к базовому классу что-то или переопределяет
какие-то стили из базового класса.

Чем это опасно?
Вы добавляете или изменяете какое-то свойство в одном из этих трёх классов, у вас нет никакой гарантии, что
ваши исправления не придут в конфликт весов со стилями других классов на этой ноде.

В большом проекте даже после небольших изменений в таких стилях хорошо бы перетестировать весь проект с нуля,
чтобы убедиться, что верстка не сломалась в тех блоках, где есть множественные классы. Проблема же в том, нет
другого механизма, кроме ручного пребора каждой страницы.

И это совсем не похоже на независимые блоки. Какая же это независимость, если даже внутри одного блока могут
родиться проблемы отображения? Трудно себе даже представить потенциальные конфликты в стилях, если мы смешаем
два разных блока на одной ноде.

### Вместо этого Бивис делает view

Мы в такой ситуации рассуждаем так. Одна нода - один блок. Если в проекте нужна кнопка с темой нормал и тенью, то должен существовать отдельный класс,
в котором сразу будет и тема нормал и тень. В одном классе. Поэтому та запись с тремя классами превращается в один класс:

```html
<div class="button_normal-shadow">кнопка</div>
```

То есть мы делам блок button с view = normal-shadow. В json это записывается нами так:

```javascript
{
    block: 'button',
    view: 'normal-shadow'
}
```

При этом, если мне нужно эту кнопку отобразить в нажатом состоянии, мне не нужно писать отдельный вью, всё решается с помощью состояний кнопки.

Мы делаем это с помощью препроцессора. Но об этом пусть расскажет Вадим.

### CSS-препроцессор

**Вадим:**
Кто сейчас не знает, что такое препроцессор? Все знают.

Кроме меня. Я относился к CSS-препроцессорам брезгливо. "Баловсто это", — я так считал, — "Тот же CSS, только с синтаксическим сахаром."
А сахар я не люблю, кофе могу пить и несладкий.

Только оказалось, что сахар в препроцессорах - это не то, ради чего они нужны.
Мы с их помощью делаем верстку гибкой и модульной.

Как мы решаем задачу?

### Публичные селекторы и приватные функции

```css
.button {
    skin-common()
    skin-theme-normal()
}

.button_normal-shadow {
    skin-common();
    skin-theme-normal();
    skin-shadow();
}

skin-common() {
    /* общие стили для кнопки */
}

skin-theme-normal() {
    /* цветовая тема */
}

skin-shadow() {
    /* стили добавляют тень */
}

```
Мы создаём два селектора, независимых друг от друга. Каждый - самодостаточный.
В каждом из них я зову некотрые функции, как мы это делаем в `JS`.

Это своего рода геттеры - функции, которые что-то возвращают вместо себя.
В Stylus-препроцессоре они называются миксины. Примеси.

`skin-common()`, `skin-theme-normal()`, `skin-shadow()` - это так называемые миксины

Мощь в том, что эти функции приватны. Они не попадают напрямую в скомпилироанный css-файл. Пока из конкретного селектора не вызову этот миксин, его содержимое нигде не светится

У меня есть селектор для обычной кнопки и такой же, но с тенью. Я зову нужные миксины.

### Все конфликты под контролем

И здесь же, на этапе препроцессора могу разрулить все конфликты, если они возникнут

```css
.button_normal-shadow {
    skin-common();
    skin-theme-normal();
    skin-shadow();

    /* а здесь разрулил все конфликты этих миксинов */
}
```

То есть мы решаем все конфликты на этапе разработки, а не на этапе использования.
В браузер пойдёт для этого блока один css-селектор. Гарантированно работающий.

Идею так использовать препроцессор мы позаимствовали у Романа Комарова. Он предложил такую же схему для своего CSS-фреймворка Stylobat. Рома - это тот парень,
который является сейчас мейнтейнером препроцессора Stylus. Гениальный верстальщик, добрый человек. Рома, спасибо тебе большое!

Марат, расскажи, пожалуйста, как мы пишем js для блоков на странице?

## JS

### В маленьких проектах

**Марат:** В маленьких проектах мы делаем так:

```javascript
$(document).ready(function() {

    var form = $('#my-form');
    form.submit(onSubmited);

    function onSubmited() {
        if ($('#my-form .button').hasClass('disabled')) {
            return false;
        }
    }

});
```

Для каждого блока мы описываем, что он должен делать.
Здесь же описываем реакции на пользовательские события.

В бивисе мы делаем то же самое, только не внутри ```$( document ).ready()```, а внутри модуля.

### В маленьких проектах с модулями

У нас есть своя модульная система, она асинхронная на всех этапах своей работы.
Примерно так выглядит описание модуля в терминах модульной системы.

То есть, тот же код, что на предыдущем слайде, только лишённый глобального экспорта.

```javascript
modules.define(
    'form',
    ['jquery'],
    function(provide, $) {

        var form = $('#my-form');
        form.submit(onSubmited);

        function onSubmited() {
            if ($('#my-form .button').hasClass('disabled')) {
                return false;
            }
        }

        provide(form);
    }
);
```
Сам код остался тем же, обвязка немного поменялась.

Мы объявили модуль в первой строке.
Во второй мы далеи модулю имя.
В третьей  описали зависимости — в нашем случае это только JQuery

И мы описали то, из чего состоит модуль. То есть то, что этот модуль экспортирует.

### В Бивисе = модули + YBlock

На самом деле, внутри модулей мы не используем напрямую JQuery. Мы используем свой базовый класс для написания блоков.

Этот класс даёт нам возможность описывать блок в виде абстракции над DOM-деревом.
И более того, мы не используем JQuery и в процессе написания самого блока, а не только использования.

```javascript
modules.define(
    'form',
    ['button', 'input', 'y-block'],
    function(provide, button, input, YBlock) {

        var Form = inherit(YBlock, {
            __constructor: function () {
                this._submitButton = YButton.find(this);
                this._bindTo(this.getDomNode(), 'submit', this._onSubmited);

            },

            _onSubmited: function (e) {
                if (this._submitButton.isDisabled()) {
                    e.preventDefault();
                } else {
                    this.emit('submit');
                }
            }
        });

        provide(Form);
    }
);
```

### Почему не jQuery?

**Вадим:** Расскажи, пожалуйста, почему не jQuery? Его же все знают.

**Марат:** Во-первых, мы получаем код, который можно вновь и вновь использовать.

А во-вторых — абстракцию над HTML-структурой блока. Нам не важно, как блок представлен на странице.
Порой нам даже не важно, где он лежит - в body или в каком-то другом элементе.

Мы переходим от DOM-взгляда на компонент на другой. Мы смотрим на блоки с точки зрения семантики их работы.

### Поведение отделено от отображения

**Вадим:** Ещё у Бивиса получилось разделить визуальное отображение и поведение блока.

Когда бивис сгенерит html для шапки, вы увидите там такое:

```html
<div
    class="header"
    data-block="header">
</div>
```

Слово `header`, записанное в атрибуте class участвует исключительно в стилях.
А то, что написано в `data-block` - именно по этому атрибуту Бивис находит шапку и назначает ей js-поведение.

В бивисе блок может иметь один css-класс, а дата-атрибут совершенно другой. То есть вы можете спокойно удалить атрибут -
поведение вы потеряете, но внешний вид блока не сломается.

### Они пересекаются в состояниях блока

Едиственное место, где поведение и отображение пересекаются, это состояния блока. Этого никак не избежать, потому что и в жизни оно так устроено.

Когда я загораю, моя кожа темнеет. А когда мне стыдно, я краснею. Но в любом состоянии я остаюсь самим собой.

В блоке тоже самое. Та же форма авторизации: по нажатию на кнопку сабмита надо проверить поле логина. Если пустое - обвести поле логина стыдливой красной рамкой. То есть изменить отображение блока,
сменить его состояние с обычного на тревожное.

Из `js` мы добавляем дополнительный класс, который отвечает за изменение внешнего вида в состоянии "тревога".

Вот что произойдёт в html-элемнте блока

```html
<input class="login _unfilled" type="text"/>
```

а вот что мы заранее напишем в стилях

```css
/* обычное состояние */
.login {
    ...
}

/* тревожное состояние */
.login._unfilled {
    border: 1px solid red;
}
```

И когда мы на клиенте проверим, что поле логина пустое, мы добавим в ноду к инпуту класс "_unfilled"
Мы называем такие классы состояниями: State.

Почему класс начинается с подчёркивания? Чтобы подчернуть, что он приватный для блока и чтобы легче его замечать.

Теперь понимаете, почему мы назвали наш подход BEViS?

```
B — [B]lock
E — [E]lement
Vi— [Vi]ew
S — [S]tate
```

Мы почти закончили. Марат, расскажи нам, как блок представлен на файловой системе.

## Файлы и блоки

### На файловой системе...

**Марат:** Конечно же мы не пишем все стили в одном файле, все шаблоны в одном файле, весь клинетский js в одном файле.
Каждый блок представлен на файловой системе своей папкой, это удобно и очень по-человечески.

Ведь у меня, как и у любого человека, есть дом — место, откуда я выхожу утром на работу и куда возвращаюсь каждый вечер.
Ну, хорошо, это не дом. Это квартира в многоэтажке.

У блока тоже есть свой дом - место, где блок отдыхает и ждёт, когда его "позовут поработать" в веб-странице.
В корне проекта есть директория `/blocks`, в ней живут все блоки. Только в ней. Это дом блоков. Не ищите других мест.
Если блока здесь нет, больше нет нигде.

````
blocks/
├── header/
│   ├── header.bt.js
│   ├── header.styl
│   └── header.js
└── form/
     ├── form.bt.js
     ├── form.styl
     └── form.js
````

Каждый блок хранится в своей собственной папке, где шаблоны для генерации html описаны в `bt.js`, стили в `styl`, клиентский яваскрипт в `js`.

### ENB

**Вадим:** Эффективно, хотя и не ново. Когда моя дочка готовится к математике, она на парту выкладывает учебник по математике, тетрадь по математике, угольник и карандаш — всё, что нужно именно для урока математики. У нас так же - всё, что нужно для блока находится в одной папке.

А когда учительница хочет проверить домашку по математике, она ходит по рядам и собирает у всех тетради по математике.
У нас тоже есть такой сборщик. Его написал Марат.

Марат, почему не Ant, Make, Grunt? Зачем ты сделал [ENB](https://github.com/enb-make/enb)?

**Марат:** Наш сборщик отличается огромной скоростью сборки для проектов с блочной структурой. И в нём есть встроенный сервер, он автоматически отслеживает изменения на фаловой системе и пересобирает файлы.

Сборка часто являлась узким местом в сложных компонентных системах, но в рамках BEViS мы полностью интегрировали сборку в процесс разработки. Работая над проектом достаточно лишь обновлять страницу в браузере, чтобы всегда видеть актуальные стили, скрипты и верстку. 

### ENB-конфигуратор

**Вадим:** А ещё у твоего сборщика очень понятная документация и робот-конфигуратор, с помощью которого создавать конфиг для сборщика сможет школьник.

### Bevis-ui документация

**Вадим:** Мы написали документацию и про бивис. Она понятная, легкая для воприятия. Мы писали её для живых людей.

### Быстрый старт

Начать работать на бивисе просто. Три команды:

[Слайд](http://makishvili.github.io/bevis/index.html?full#56)

```
git clone git@github.com:bevis-ui/bevis-stub.git your-project
cd your-project
make
```

После этого мы открываем в браузере ```localhost:8000``` и говорим: "Привет, Бивис!"

### TodoMVC

**Марат:** Кроме того, мы реализовали страницу в стиле TodoMVC на Бивисе.

Можно сравнить Бивис с другими MVC и компонентными фреймворками.

Ещё мы сделали движдок для блогов. Он такой же как Октопресс, только не на руби и джекилле, а на серверном яваскрипте.

## Заключение

**Вадим:** Нам нравится пользоваться Бивисом.

Во-первых, потому что мы сами его придумали. Своя рубашка ближе к телу, кто спорит :)

Во-вторых, бивис на 99% - это обычный javascript.

В-третьих, код бивиса на 100% юнит-тестами.

И последняя причина, код написан в очень понятном кодстайле, которого придерживается команда Яндекс.Карт.

Мы не просим становиться нашими контрибьюторами, потому что особо нечего контрибьютить. Ведь наши
инструменты просто работают, а бивис-подход вполне жизнеспособный, мы доказали это на нескольких проектах.
Например `beta.maps.yandex.ru` сделан на бивисе.

Мы не предлагаем вам пересаживаться на бивис, если у вас маленькие сайты. Мы осознаём, что верстать на бивисе маленький сайтик —
это все равно что экскаватором пытаться выкопать лунку для гольфа — вместо лунки всё равно получится яма для саженца.

Но если вдруг вам нужно перекопать большое поле и вы хотите быть уверены, что в процессе копания не повредите
какие-то важные подземные коммуникации, тогда бивис - и для вас тоже.

**Марат:** Да, Бивис - для больших сайтов, которым нужна простота и надёжность.

С вами была команда Яндекс.Карт и её представители на этой конференции - Вадим Макишвили и Марат Дулин. Спасибо вам большое за внимание!
